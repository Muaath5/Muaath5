<div dir="auto">
  
 # حلول الاختبار التأهيلي أذكى 2024 بلغة بايثون

كتب هذا الملف:
- معاذ القرني
- يزن آشي

وهذا الملف ملكية [لقناة أذكى](https://t.me/MawhibaNOPAI)



| الاسم            | الدرجة   | هل تختلف المعطيات بين الطلاب؟  |
|-----------------|-------|------------------------|
|  الجملة الشرطية  IF  | 20    | نعم                     |
| التكرار           | 31     | نعم                    |
|  معادلة خالد       | 37     | نعم                    |
|  الاستدعاء الذاتي لعبير | 40    | نعم                    |
|  واجب ريم المنزلي   | 42    | نعم                    |
|  الأعداد الجيدة      | 43    | نعم                    |
|  المجموعة الجزئية    | 44    | لا                    |

##  الجملة الشرطية IF 
**الفكرة:** ننسخ الكود ونضيف أمر طباعة للمتغير المطلوب


<details style="padding: 10px">
  <summary>الحل بلغة بايثون</summary>
  
```py
x = 11
y = 29

if x % 2 != 0:
    if x > y:
        z = 0
    else:
        z = 1
else:
    if x > y:
        z = 2
    else:
        z = 3

print(z) # أضفنا أمر الطباعة
```

</details>

## التكرار
**الفكرة:** ننسخ الكود ونضيف أمر طباعة للمتغير المطلوب


<details style="padding: 10px">
  <summary>الحل بلغة بايثون</summary>

```py
r = 0
for i in range(100):
    r = (277 * r + 241) % 433
print(r) # أضفنا أمر الطباعة
```
  
</details>

##  معادلة خالد 
**الفكرة:** تجربة جميع الاحتمالات

<details style="padding: 10px">
  <summary>الحل بلغة بايثون</summary>

```py
P = 35171
A = 24636

for x in range(1, 1000000):
    if (x * A % P == 1):
        print(x)
        exit()
```
  
</details>

##  الاستدعاء الذاتي لعبير 

<details style="padding: 10px">
  <summary>خوارزمية الاستدعاء الذاتي (ريكيرجن / Recursion)</summary>

**الفكرة:** تطبيق العطيات بتحويل المسألة إلى دالة ثم استدعائها كل مرة، وتذكر النتائج السابقة (memoization)

```py
N = 257 # اكتب الرقم المطلوب
MOD = 193 # اكتب الرقم بعد باقي القسمة

memo = [-1] * N+1;
def rec(i: int) -> int:
    if (memo[i] != -1):
        return memo[i]
    return memo[i] = (rec(i-3) + rec(i-2) * rec(i-1)) % MOD;

memo[1] = 1
memo[2] = 2
memo[3] = 3
print(rec(N))
```

</details>


<details>
  <summary>الحل باستخدام البرمجة الديناميكية (Dynamic Programming / DP)</summary>
  <b>الفكرة: تطبيق المعادلة كما هي</b>

```py
N = 257 # اكتب الرقم المطلوب
MOD = 193 # اكتب الرقم بعد باقي القسمة

dp = [0] * N+1
dp[1] = 1
dp[2] = 2
dp[3] = 3
for i in range(4, N+1):
    dp[i] = (dp[i-3] + dp[i-2] * dp[i-1]) % MOD;
print(dp[N])
```
  
</details>

##  واجب ريم المنزلي


<details style="padding: 10px">
  <summary>البحث الثنائي (Binary Search)</summary>

**الفكرة:** وجود حد أعلى للإجابة (نسميه $أ$) وحد أعلى للإجابة (نسميه $ب$)، ثم نختار عدد في المنتصف $\frac{ب + أ}{2}$، ونغير الحد الأدنى والأعلى بناءً على نتيجة الدالة لهذا الرقم.

**ملاحظة:** يمكن تطبيق هذه الفكرة يدويًا باستعمال الحاسبة أو برامج الرسم البياني دون الحاجة لكتابة برنامج
```py
from math import *

Y = 482.15385787945286;
PREC = 1e-4;

def f(x):
    return (x+exp(x/100))

l = 1, r = 10000
while (abs(l - r) > PREC):
    mid = (l + r) / 2;
    if (f(mid) <= Y):
        l = mid;
    else:
        r = mid - PREC;
    
print(l)
```

</details>

##  الأعداد الجيدة 


<details>
  <summary>تجربة جميع الاحتمالات</summary>

```py
L = 207418 # نضع هنا قيم المعطيات 
R = 691140 # نضع هنا قيم المعطيات 

def isgood(xx: int) -> int
    x = str(xx);
    a=int(x[0])
    b=int(x[1])
    c=int(x[2])
    d=int(x[3])
    e=int(x[4])
    f=int(x[5])
    return ((a*c+d*f) == (a+b)*e-f ? 1 : 0)

sol = 0;
for i in range(L, R+1):
    sol += isgood(i)
print(sol)
```
  
</details>




##  المجموعة الجزئية 


<details>
  <summary>تجربة كل الاحتمالات مع خوارزمية الالتقاء في المنتصف (Meet in the middle) باستعمال الاستدعاء الذاتي (Recursion)</summary>

**الفكرة:** بما أن عدد الاحتمالات عالي جدًا ($= 2^{40} = 10^{12}$ 1 ترليون)، واللغات في المتوسط تنجز ($= 10^8$ 100 مليون) عملية في الثانية، يعني أن البرنامج لو جرب كل الاحتمالات سيستغرق حوالي ساعتين ونصف!

**الاختصار:** نقسم مجموعة الأعداد إلى نصفين، ونجرب جميع الاحتمالات في كل نصف، ثم نجرب كل احتمالات الدمج ونستعمل البحث الثنائي للاختصار الإضافي
                
```py
الكود غير متوفر
```

</details>
	

<details>
  <summary>تجربة كل الاحتمالات مع خوارزمية الالتقاء في المنتصف (Meet in the middle) باستعمال تمثيل الأرقام الثنائية (Bitmasks)</summary>

```py
الكود غير متوفر
```
  
</details>

 
<details>
  <summary>الحل باستعمال البرمجة الديناميكية (Dynamic Programming / DP)</summary>

```py
الكود غير متوفر
```
        
  </details>

  
<details style="padding: 10px">
   <summary>تجربة احتمالات عشوائية</summary>

   <b>ملاحظة: هذه الفكرة قد تطبع أرقام خاطئة، لأنها تعتمد على العشوائية، لكن كل ما زادت عدد المحاولات زادت الدقة، وهي غالبًا تطبع نتائج صحيحة</b>
  
```py
الكود غير متوفر
```
        
</details>

</div>
